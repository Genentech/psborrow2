---
title: "Conduct a simulation study"
author: "Matt Secrest, Yichen Lu, Isaac Gravestock"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    code_folding: show
vignette: >
  %\VignetteIndexEntry{4. Conduct a simulation study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  fig.width = 5,
  fig.height = 3,
  dpi = 120,
  fig.align = "center"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

In this vignette, you'll learn how to use `psborrow2` to create a
simulation study with the goal of informing trial design. Let's
load `psborrow2` to start:

```{r setup, message = FALSE}
library(psborrow2)
```

# Bringing your own simulated data

We'll start by showing how to conduct a simulation study when you bring your
own simulated data. To execute a simulation study with your own data,
we need to build an object of class `Simulation` using the function
`create_simulation_obj()`. Let's look at the arguments to
`create_simulation_obj()` and consider them one-by-one below:

```
create_simulation_obj(
  data_matrix_list,
  outcome,
  borrowing,
  covariate,
  treatment
)

```

## `data_matrix_list`

`data_matrix_list` is where you input the data you will be using for the
simulation study using the function `sim_data_list()`.
Let's simulate some data together for the sake of example.
We'll use the `simsurv` package to generate survival data under three
scenarios: a true hazard ratio (HR) for the treatment effect of 0.6, 0.8, and 1.0.
Similarly we'll look at three drift HR scenarios: 0.5, 1.0, and 1.5.

### `data_list`

Looking at the arguments to `sim_data_list()`, the first argument, `data_list`
requires a list of lists of matrices. Each list of matrices should represent
a different data generation scenario, such as our difference true HR.
Therefore, let's create an object `data_list` that is considers all combinations
of true HRs of 0.6, 0.8, and 1.0 and drift HRs of 0.5, 1.0, and 1.5. That gives us
9 total scenarios, and we'll simulate 20 datasets within each scenario.

```{r}
library(simsurv)
library(survival)

# Simulate a single matrix
sim_single_matrix <- function(true_hr = 0.6,
                              drift_hr = 1.0,
                              n = 600) {
  # Create a data frame with the subject IDs and treatment covariate
  cov <- data.frame(
    id = 1:n,
    trt = rbinom(n, 1, 0.5)
  )
  cov$ext <- ifelse(cov$trt == 1L, 0L, rbinom(sum(cov$trt), 1, 0.5))

  # Simulate the event times
  dat <- simsurv(
    lambdas = 0.1,
    gammas = 1.5,
    betas = c(
      trt = log(true_hr),
      ext = log(drift_hr)
    ),
    x = cov,
    maxt = 5
  )

  dat$censor <- 1 - dat$status

  # Merge the simulated event times onto covariate data frame
  dat <- merge(cov, dat)

  as.matrix(dat)
}

# Set seed
set.seed(112233)

# Create data list
data_list <- list(
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.6)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.8)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 1.0)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.6, drift_hr = 1.5)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.8, drift_hr = 1.5)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 1.0, drift_hr = 1.5)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.6, drift_hr = 0.5)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.8, drift_hr = 0.5)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 1.0, drift_hr = 0.5))
)
```

As you can see, `data_list` is a list of list of matrices, the correct format
for inputting into `sim_data_list()`:

```{r}
str(data_list)
```

At the lowest level are matrices of simulated data:
```{r}
head(data_list[[1]][[1]])
```

### `guide`
In order to summarize the results from the different parameters in
your simulation study, `psborrow2` needs to know how the simulation parameters
differ. That is the purpose of the argument `guide`, which is a `data.frame`
that distinguishes the simulation study parameters. Three columns are required
in `guide`, though many more can be provided. The three required columns are:

* The true treatment effect (in our case a HR)
* The true drift effect (in our case a HR). Drift effects >1 will mean
that the external control arm experiences greater hazard than the internal
control arm.
* The name of a column that indexes the `data_list`

We varied the true HR so that it took
three values: 0.6, 0.8, and 1.0. We also varied  the drift HR so it took three
values: 0.5, 1.0, and 1.5. Our guide should therefore be nine rows to represent
the nine scenarios. We pass `c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L)` onto `index`
to clarify that `data_list[[1L]]` corresponds to the settings in the first row,
`data_list[[2L]]` to the second row, and so on.

```{r}
guide <- data.frame(
  trueHR = rep(c(0.6, 0.8, 1.0), 3),
  driftHR = rep(c(1.0, 1.5, 0.5), each = 3),
  index = 1L:9L
)

guide
```

### `effect`, `drift`, and `index`

The last three inputs to `sim_data_list()`, `effect`, `drift`, and `index`
are the column names in `guide` that correspond to the true treatment effect,
true drift effect, and index of the `data_list` items, respectively.
For our study, these are `"trueHR"`, `"driftHR"`, and `"index"`.

Putting it all together, we can create an object of class `SimDataList`:

```{r}
sdl <- sim_data_list(
  data_list,
  guide,
  "trueHR",
  "driftHR",
  "index"
)

sdl
```

## `outcome`

`outcome` is where you pass information on the study outcomes. You can pass
either a single `Outcome` class object (e.g., as produced by `exp_surv_dist()`),
or a list of `Outcome` class objects passed to `sim_outcome_list()`. For our
example, let's just use a single exponential distribution.

```{r}
out <- exp_surv_dist(
  time_var = "eventtime",
  cens_var = "censor",
  baseline_prior = normal_prior(0, 1000)
)
out
```

## `borrowing`

`borrowing` is where we input information on the type of borrowing we want to
evaluate. This can be either a single object of class `Borrowing` or
a list of objects created with `sim_borrowing_list()`. For the sake of example,
let's assume we are interested in comparing three borrowing scenarios:

* No borrowing
* BDB, conservative prior
* BDB, aggressive prior

We will create a borrowing list with `sim_borrowing_list()`.

```{r}
sbl <- sim_borrowing_list(
  list(
    "No borrowing" = borrowing_details("No borrowing", "ext"),
    "BDB, conservative prior" = borrowing_details("BDB", "ext", gamma_prior(0.001, 0.001)),
    "BDB, aggressive prior" = borrowing_details("BDB", "ext", gamma_prior(1.000, 0.001))
  )
)
sbl
```


## `covariate`

`covariate` is for information on covariate adjustment details. This can be
a single instance of class `Covariates` (from `add_covariates()` or a list of
`Covariates` objects created by `sim_covariate_list()` . This is also the only
argument that is not required in `create_simulation_obj`. Let's leave
this argument empty (i.e., let's not adjust for any covariates).

## `treatment`

`treatment` is where we input the treatment details for our simulation study.
As with other inputs, this can be a single instance of a class (`Treatment`),
or a list of these classes, created with `sim_treatment_list()`. Let's
just use a single instance:

```{r}
txd <- treatment_details("trt", normal_prior(0, 1000))
```

## `create_simulation_obj()`

Now that we have all of the relevant inputs for `create_simulation_obj()`,
let's call the function, which will generate and compile Stan models
ready to sample on our behalf.

***Important:*** `psborrow2` will simulate the Cartesian product of all
unique list elements in `data_matrix_list`, `outcome`, `borrowing`,
`covariate`, and `treatment`. `data_matrix_list` contains nine
different study parameters and therefore contains a list of length nine.
`borrowing` has three scenarios and is a list of length three. The rest
contain just one input (or 0 for `covariate`, which is equivalent to one
scenario). This means we should expect $9 \times 3 = 27$ combinations of
parameters. Let's create a simulation object of class `Simulation`:

```{r}
sim_obj <- create_simulation_obj(
  data_matrix_list = sdl,
  outcome = out,
  borrowing = sbl,
  treatment = txd
)
sim_obj
```

While we get a warning about the size of the simulation study, we are not worried
because we are limiting our MCMC samples below in this example.

We can access the guide to see the specific scenarios that will be
simulated with `show_guide()`:

```{r}
show_guide(sim_obj)
```

## `mcmc_sample()`

Now that we've created a simulation object, we're ready to call `mcmc_sample()`
and generate draws for our model. For now, we will stick with the default inputs.

***Note*** unlike an analysis on a single dataset, `mcmc_sample()` does not
return a `CmdStanModel` object when applied to a simulation study object.
Instead, it returns a class unique to simulation study results:
`MCMCSimulationResult`.

***Note*** there is one important additional argument to `mcmc_sample()` for
simulation objects: `posterior_quantiles`. This numeric vector of length 2
specifies the quantiles for null coverage and true coverage. For instance,
95% credible coverage would be estimated with
`posterior_quantiles = c(0.025, 0.975)`, the default argument.

```{r, include = FALSE}
st <- Sys.time()
results <- mcmc_sample(
  sim_obj,
  posterior_quantiles = c(0.025, 0.975),
  iter_warmup = 400,
  iter_sampling = 1000,
  chains = 1L,
  seed = 112233
)
en <- Sys.time()
```

```{r, eval = FALSE}
results <- mcmc_sample(
  sim_obj,
  iter_warmup = 400,
  iter_sampling = 1000,
  chains = 1L,
  seed = 112233
)
```

This evaluation took about `r format(round(as.numeric(difftime(en, st, units = "min")), 1), nsmall=1)`
minutes. Let's look at the performance of our simulation study by extracting the data.frame
that summarizes results, `get_results()`:

```{r}
results_df <- get_results(results)
head(results_df)
```

Let's quickly visualize the results using `ggplot2`:

## Summary of results

As an example of the types of visual summaries you can provide on simulation
study results, let's explore performance of several some select metrics:

### MSE

```{r class.source = "fold-hide", fig.dim = c(5, 3), dpi = 140}
library(ggplot2)
ggplot(results_df) +
  geom_bar(aes(x = factor(trueHR), fill = borrowing_scenario, y = mse_mean), stat = "identity", position = "dodge") +
  labs(
    fill = "Borrowing scenario",
    x = "True HR",
    y = "MSE (mean)"
  ) +
  facet_wrap(~ paste0("drift HR = ", driftHR)) +
  scale_fill_manual(values = c("#29339B", "#74A4BC", "#B6D6CC"))
```

From this graph, it is clear that the impact of aggressive borrowing
depends greatly on the drift HR between the internal and external controls.

### Null coverage

Null coverage refers to the proportion of specified credible intervals
(in this case, 95% credible intervals) that contain the null effect (1.0).
When the true hazard ratio is not 1.0, this refers to the type II error proportion.

```{r class.source = "fold-hide", fig.dim = c(5, 3), dpi = 140}
ggplot(results_df[results_df$trueHR != 1.0, ]) +
  geom_bar(aes(x = factor(trueHR), fill = borrowing_scenario, y = null_coverage),
    stat = "identity", position = "dodge"
  ) +
  labs(
    fill = "Borrowing scenario",
    x = "True HR",
    y = "Type II error"
  ) +
  facet_wrap(~ paste0("drift HR = ", driftHR)) +
  scale_fill_manual(values = c("#29339B", "#74A4BC", "#B6D6CC"))
```

The type II error proportion is higher when the true hazard ratio is 0.8 and
generally when no borrowing is used.

When the true hazard ratio is equal to 1.0, this refers to the compliment of
the type I error proportion, which we can use to derive type I error:

```{r class.source = "fold-hide", fig.dim = c(5, 3), dpi = 140}
ggplot(results_df[results_df$trueHR == 1.0, ]) +
  geom_bar(aes(x = factor(driftHR), fill = borrowing_scenario, y = 1 - null_coverage),
    stat = "identity", position = "dodge"
  ) +
  labs(
    fill = "Borrowing scenario",
    x = "drift HR",
    y = "Type I error"
  ) +
  scale_fill_manual(values = c("#29339B", "#74A4BC", "#B6D6CC"))
```

### True coverage

True coverage refers to the proportion of simulations that contain
the effect estimate of interest.

```{r class.source = "fold-hide", fig.dim = c(5, 3), dpi = 140}
ggplot(results_df) +
  geom_bar(aes(x = factor(trueHR), fill = borrowing_scenario, y = true_coverage),
    stat = "identity", position = "dodge"
  ) +
  labs(
    fill = "Borrowing scenario",
    x = "True HR",
    y = "True coverage"
  ) +
  facet_wrap(~ paste0("drift HR = ", driftHR)) +
  scale_fill_manual(values = c("#29339B", "#74A4BC", "#B6D6CC"))
```

It looks like almost all of our analyses captured the effect estimate of interest.
