---
title: "Conduct a simulation study"
author: "Matt Secrest, Yichen Lu, Isaac Gravestock"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    code_folding: show
vignette: >
  %\VignetteIndexEntry{4. Conduct a simulation study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  fig.width = 5,
  fig.height = 3,
  dpi = 120,
  fig.align = "center"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

In this vignette, you'll learn how to use `psborrow2` to create a
simulation study with the goal of informing trial design. Let's
load `psborrow2` to start:

```{r setup, message = FALSE}
library(psborrow2)
```

# Bringing your own simulated data

We'll start by showing how to conduct a simulation study when you bring your
own simulated data. To execute a simulation study with your own data,
we need to build an object of class `Simulation` using the function
`create_simulation_obj()`. Let's look at the arguments to
`create_simulation_obj()` and consider them one-by-one below:

```
create_simulation_obj(
  data_matrix_list,
  outcome,
  borrowing,
  covariate,
  treatment
)

```

## `data_matrix_list`

`data_matrix_list` is where you input the data you will be using for the
simulation study using the function `sim_data_list()`.
Let's simulate some data together for the sake of example.
We'll use the `simsurv` package to generate survival data under two
scenarios: a true hazard ratio (HR) for the treatment effect of 0.6 and a true
HR of 0.8.

### `data_list`

Looking at the arguments to `sim_data_list()`, the first argument, `data_list`
requires a list of lists of matrices. Each list of matrices should represent
a different data generation scenario, such as our difference true HR.
Therefore, let's create an object `data_list` that is length two:
one list for a HR of 0.6, and one for a HR of 0.8. Within
these lists, we can provide any number of matrices. We'll
do 20 in this example.

```{r}
library(simsurv)
library(survival)

# Simulate a single matrix
sim_single_matrix <- function(true_hr = 0.6,
                              drift_hr = 1.0,
                              n = 600) {
  # Create a data frame with the subject IDs and treatment covariate
  cov <- data.frame(
    id = 1:n,
    trt = rbinom(n, 1, 0.5)
  )
  cov$ext <- ifelse(cov$trt == 1L, 0L, rbinom(sum(cov$trt), 1, 0.5))

  # Simulate the event times
  dat <- simsurv(
    lambdas = 0.1,
    gammas = 1.5,
    betas = c(
      trt = log(true_hr),
      ext = log(drift_hr)
    ),
    x = cov,
    maxt = 5
  )

  dat$censor <- 1 - dat$status

  # Merge the simulated event times onto covariate data frame
  dat <- merge(cov, dat)

  as.matrix(dat)
}

# Set seed
set.seed(112233)

# Create data list
data_list <- list(
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.6)),
  lapply(1:20, function(z) sim_single_matrix(true_hr = 0.8))
)
```

`data_list` is a list of list of matrices, the correct format
for inputting into `sim_data_list()`. At the lowest level are matrices of simulated data:
```{r}
head(data_list[[1]][[1]])
```

### `guide`
In order to summarize the results from the different parameters in
your simulation study, `psborrow2` needs to know how the simulation parameters
differ. That is the purpose of the argument `guide`, which is a `data.frame`
that distinguishes the simulation study parameters. Three columns are required
in `guide`, though many more can be provided. The three required columns are:

* The true treatment effect (in our case a HR)
* The true drift effect (in our case a HR). Drift effects >1 will mean
that the external control arm experiences greater hazard than the internal
control arm.
* The name of a column that indexes the `data_list`

In our study, the drift HR was 1.0. We varied the true HR so that it took
two values: 0.6 and 0.8. Our guide should therefore be two rows to represent
the two scenarios. We pass `c(1L, 2L)` onto `index` to clarify that
`data_list[[1L]]` corresponds to the settings in the first row and
`data_list[[2L]]` to the second row.

```{r}
guide <- data.frame(
  trueHR = c(0.6, 0.8),
  driftHR = c(1.0, 1.0),
  index = c(1L, 2L)
)

guide
```

### `effect`, `drift`, and `index`

The last three inputs to `sim_data_list()`, `effect`, `drift`, and `index`
are the column names in `guide` that correspond to the true treatment effect,
true drift effect, and index of the `data_list` items, respectively.
For our study, these are `"trueHR"`, `"driftHR"`, and `"index"`.

Putting it all together, we can create an object of class `SimDataList`:

```{r}
sdl <- sim_data_list(
  data_list,
  guide,
  "trueHR",
  "driftHR",
  "index"
)

sdl
```

## `outcome`

`outcome` is where you pass information on the study outcomes. You can pass
either a single `Outcome` class object (e.g., as produced by `exp_surv_dist()`),
or a list of `Outcome` class objects passed to `sim_outcome_list()`. For our
example, let's just use a single exponential distribution.

```{r}
out <- exp_surv_dist(
  time_var = "eventtime",
  cens_var = "censor",
  baseline_prior = normal_prior(0, 1000)
)
out
```

## `borrowing`

`borrowing` is where we input information on the type of borrowing we want to
evaluate. This can be either a single object of class `Borrowing` or
a list of objects created with `sim_borrowing_list()`. For the sake of example,
let's assume we are interested in comparing four borrowing scenarios:

* No borrowing
* Full borrowing
* BDB, conservative prior
* BDB, aggressive prior

We will create a borrowing list with `sim_borrowing_list()`.

```{r}
sbl <- sim_borrowing_list(
  list(
    "No borrowing" = borrowing_details("No borrowing", "ext"),
    "Full borrowing" = borrowing_details("Full borrowing", "ext"),
    "BDB, conservative prior" = borrowing_details("BDB", "ext", gamma_prior(0.001, 0.001)),
    "BDB, aggressive prior" = borrowing_details("BDB", "ext", gamma_prior(1.000, 0.001))
  )
)
sbl
```

## `covariate`

`covariate` is for information on covariate adjustment details. This can be
a single instance of class `Covariates` (from `add_covariates()` or a list of
`Covariates` objects created by `sim_covariate_list()` . This is also the only
argument that is not required in `create_simulation_obj`. Let's leave
this argument empty (i.e., let's not adjust for any covariates).

## `treatment`

`treatment` is where we input the treatment details for our simulation study.
As with other inputs, this can be a single instance of a class (`Treatment`),
or a list of these classes, created with `sim_treatment_list()`. Let's
just use a single instance:

```{r}
txd <- treatment_details("trt", normal_prior(0, 1000))
```

## `create_simulation_obj()`

Now that we have all of the relevant inputs for `create_simulation_obj()`,
let's call the function, which will generate and compile Stan models
ready to sample on our behalf.

***Important:*** `psborrow2` will simulate the Cartesian product of all
unique list elements in `data_matrix_list`, `outcome`, `borrowing`,
`covariate`, and `treatment`. `data_matrix_list` contains two
different study parameters and therefore contains a list of length two.
`borrowing` has four scenarios and is a list of length four. The rest
contain just one input (or 0 for `covariate`, which is equivalent to one
scenario). This means we should expect $2 \times 4 = 8$ combinations of
parameters. Let's create a simulation object of class `Simulation`:

```{r}
sim_obj <- create_simulation_obj(
  data_matrix_list = sdl,
  outcome = out,
  borrowing = sbl,
  treatment = txd
)
sim_obj
```

We can access the guide to see the specific scenarios that will be
simulated with `show_guide()`:

```{r}
show_guide(sim_obj)
```

## `mcmc_sample()`

Now that we've created a simulation object, we're ready to call `mcmc_sample()`
and generate draws for our model. For now, we will stick with the default inputs.

***Note*** unlike an analysis on a single dataset, `mcmc_sample()` does not
return a `CmdStanModel` object when applied to a simulation study object.
Instead, it returns a class unique to simulation study results:
`MCMCSimulationResult`.

***Note*** there is one important additional argument to `mcmc_sample()` for
simulation objects: `posterior_quantiles`. This numeric vector of length 2
specifies the quantiles for null coverage and true coverage. For instance,
95% credible coverage would be estimated with
`posterior_quantiles = c(0.025, 0.975)`, the default argument.

```{r, include = FALSE}
st <- Sys.time()
results <- mcmc_sample(
  sim_obj,
  posterior_quantiles = c(0.025, 0.975),
  iter_warmup = 400,
  iter_sampling = 1000,
  chains = 1L,
  seed = 112233
)
en <- Sys.time()
```

```{r, eval = FALSE}
results <- mcmc_sample(
  sim_obj,
  iter_warmup = 400,
  iter_sampling = 1000,
  chains = 1L,
  seed = 112233
)
```

This evaluation took about `r format(round(as.numeric(difftime(en, st, units = "min")), 1), nsmall=1)`
minutes. Let's look at the performance of our simulation study by extracting the data.frame
that summarizes results, `get_results()`:

```{r}
results_df <- get_results(results)
print(results_df)
```

Let's quickly visualize the results using `ggplot2`:

## Summary of results

As an example of the types of visual summaries you can provide on simulation
study results, let's explore performance of several different metrics:

### Bias

```{r class.source = "fold-hide"}
library(ggplot2)
ggplot(results_df) +
  geom_tile(aes(x = borrowing_scenario, y = factor(trueHR), fill = bias_mean)) +
  labs(
    fill = "Bias (mean)",
    x = "Borrowing type",
    y = "True HR"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

On the basis of these results, it loos like bias was higher, on average,
when the true hazard ratio was greater. This makes sense.

### MSE

```{r class.source = "fold-hide"}
ggplot(results_df) +
  geom_tile(aes(x = borrowing_scenario, y = factor(trueHR), fill = mse_mean)) +
  labs(
    fill = "MSE (mean)",
    x = "Borrowing type",
    y = "True HR"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

The same is true of MSE. The true hazard ratio of 0.6 had lower MSE on
average than a hazard ratio of 0.8.

### Null coverage

Null coverage refers to the proportion of specified credible intervals
(in this case, 95% credible intervals) that contain the null effect (1.0).
When the true hazard ratio is not 1.0, this refers to the type II error proportion.

```{r class.source = "fold-hide"}
ggplot(results_df) +
  geom_bar(aes(
    x = borrowing_scenario,
    y = null_coverage,
    fill = factor(trueHR)
  ),
  stat = "identity",
  position = "dodge"
  ) +
  labs(
    x = "Borrowing type",
    fill = "True HR",
    y = "Type II error"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

The type II error proportion is much higher when the true hazard ratio is 0.8
compared to 0.6, as we might anticipate.

### True coverage

True coverage refers to the proportion of analyses simulations that contain
the effect estimate of interest.

```{r class.source = "fold-hide"}
ggplot(results_df) +
  geom_bar(aes(
    x = borrowing_scenario,
    y = true_coverage,
    fill = factor(trueHR)
  ),
  stat = "identity",
  position = "dodge"
  ) +
  labs(
    x = "Borrowing type",
    fill = "True HR",
    y = "Coverage of true effect"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

It looks like almost all of our analyses captured the effect estimate of interest.
